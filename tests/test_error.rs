#[cfg(test)]
mod tests {
    use rust_error_handling::*;

    #[test]
    fn create_error() {
        let err = err_create!(CustomError::new("Error message"));
        // check if line generated by macro is correct, note that moving this line
        // relative to err_create will break test
        assert_eq!(err.line, line!() - 3);
        assert!(err.column > 0);
        assert_eq!(err.file, file!());
    }

    #[test]
    fn map_error() {
        let err = "invalid".parse::<i32>().map_err(err_from!()).unwrap_err();
        // check if line generated by macro is correct, note that moving this lines
        // relative to err_create will break test
        assert_eq!(err.line, line!() - 3);
        assert!(err.column > 0);
        assert_eq!(err.file, file!());
        match err.inner {
            ErrorBag::ParseError(_) => println!("parse error OK"),
            _ => panic!("Wrong error type"),
        };
    }

    #[test]
    fn map_error_msg() {
        let str = "invalid";
        let err = str
            .parse::<i32>()
            .map_err(err_from_msg!("Failed to parse: {}", str))
            .unwrap_err();
        // check if line generated by macro is correct, note that moving this lines
        // relative to err_create will break test
        assert_eq!(err.line, line!() - 3);
        assert!(err.column > 0);
        assert_eq!(err.file, file!());
        match err.inner {
            ErrorBag::ParseError(_) => println!("parse error OK"),
            _ => panic!("Wrong error type"),
        };
        assert_eq!(err.msg.unwrap(), "Failed to parse: invalid");
    }
}
